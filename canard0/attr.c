/* ----------------------------------------------------------------------
! ----------------------------------------------------------------------
! Slow manifolds computation in the Tran system 
! ----------------------------------------------------------------------
! C o m p.  o f  t h e  a t t r a c t i n g  s l o w  m a n i f o l d   
! ----------------------------------------------------------------------
! Homotopy step 1: "away from the folded node along the fold curve"
! followed by
! Homotopy step 2: "away from the fold curve on the critical manifold"
! followed by
! Actual computation of the attracting slow manifold
! ----------------------------------------------------------------------
! (Ref.: Desroches, Krauskopf and Osinga, CHAOS 18, 015107 (2008))        
! ----------------------------------------------------------------------
! --------------------------------------------------------------------*/

/*
 *  Luofixedpoints_av.c
 *
 *  AUTO C file for the vector field named: Luofixedpoints
 *
 *  This file was generated by the program VFGEN, version: 2.5.0
 *  Generated on 11-Jan-2019 at 16:28
 */

#include <math.h>
#include "auto_f2c.h"

/*
 *  FUNC  Defines the vector field and its derivatives
 */

int func(integer ndim_, const doublereal *u_, const integer *icp_,
         const doublereal *par_, integer ijac_,
         doublereal *f_, doublereal *dfdu_, doublereal *dfdp_)
{
    integer dfdu__dim1, dfdp__dim1;
    const double Ki = 145.0;
    const double Nao = 140.0;
    const double Nai = 18.0;
    const double PRNaK = 1.8329999999999999e-02;
    const double R = 8.3144598000000005e+03;
    const double Kelvin = 3.0450000000000000e+02;
    const double Faraday = 9.5484559999999998e+04;
    const double cda = 9.5000000000000001e-02;
    const double cdb = 7.0000000000000007e-02;
    const double cfa = 1.2000000000000000e-02;
    const double cfb = 6.4999999999999997e-03;
    const double cxa = 5.0000000000000001e-04;
    const double cxb = 1.2999999999999999e-03;
    const double cxi = 2.8370000000000002e+00;
    const double cK1a = 1.0200000000000000e+00;
    const double cK1b = 4.9124000000000001e-01;
    const double Vda = -5.0000000000000000e+00;
    const double Vdb = 4.4000000000000000e+01;
    const double Vfa = 2.8000000000000000e+01;
    const double Vfb = 3.0000000000000000e+01;
    const double Vxa = 5.0000000000000000e+01;
    const double Vxb = 2.0000000000000000e+01;
    const double Vxi1 = 7.7000000000000000e+01;
    const double Vxi2 = 3.5000000000000000e+01;
    const double sda1 = -1.0000000000000000e-02;
    const double sda2 = -7.1999999999999995e-02;
    const double sdb1 = -1.7000000000000001e-02;
    const double sdb2 = 5.0000000000000003e-02;
    const double sfa1 = -8.0000000000000002e-03;
    const double sfa2 = 1.4999999999999999e-01;
    const double sfb1 = -2.0000000000000000e-02;
    const double sfb2 = -2.0000000000000001e-01;
    const double sxa1 = 8.3000000000000004e-02;
    const double sxa2 = 5.7000000000000002e-02;
    const double sxb1 = -5.9999999999999998e-02;
    const double sxb2 = -4.0000000000000001e-02;
    const double sxi = 4.0000000000000001e-02;
    const double sK1a = 2.3849999999999999e-01;
    const double sK1b1 = 8.0320000000000003e-02;
    const double sK1b2 = 6.1749999999999999e-02;
    const double sK1b3 = -5.1429999999999998e-01;
    const double sKp = 1.6722408026755853e-01;
    const double gK1w = 6.0470000000000002e-01;
    const double gKp = 1.8300000000000000e-02;
    const double gb = 3.9210000000000002e-02;
    const double VKp = 7.4880000000000004e+00;
    const double Vb = 5.9869999999999997e+01;
    double V, d, f, x;
    double C, Ko, gKw, gCa, VCa, alpha, beta, gamma, T;
    double gK, gK1, VK, VK1, alphad, betad, taud, dinf, alphaf, betaf, tauf, finf, alphax, betax, taux, xinf, xi, alphaK1, betaK1, K1inf, Kp, ICa, IK, IK1, IKp, Ib;

    /* Define state variables */

    V          = u_[0];
    d          = u_[1];
    f          = u_[2];
    x          = u_[3];

    /* Define system parameters */

    C          = par_[0];
    Ko         = par_[1];
    gKw        = par_[2];
    gCa        = par_[3];
    VCa        = par_[4];
    alpha      = par_[5];
    beta       = par_[6];
    gamma      = par_[7];

    /* Define the integration time as a parameter */

    T	       = par_[10];

    /* Vector field expressions */

    gK = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gKw;
    gK1 = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gK1w;
    VK = 1.0/Faraday*log(( PRNaK*Nao+Ko)/( Ki+PRNaK*Nai))*R*Kelvin;
    VK1 = 1.0/Faraday*R*log(1.0/Ki*Ko)*Kelvin;
    alphad = exp(( Vda+V)*sda1)/( exp(sda2*( Vda+V))+1.0)*cda;
    betad = 1.0/( exp(sdb2*( Vdb+V))+1.0)*exp(sdb1*( Vdb+V))*cdb;
    taud = 1.0/( alphad+betad)*alpha;
    dinf = alphad/( alphad+betad);
    alphaf = cfa*exp(sfa1*( V+Vfa))/( exp(sfa2*( V+Vfa))+1.0);
    betaf = cfb/( exp(sfb2*( Vfb+V))+1.0)*exp(sfb1*( Vfb+V));
    tauf = 1.0/( betaf+alphaf)*beta;
    finf = 1.0/( betaf+alphaf)*alphaf;
    alphax = 1.0/( exp(( Vxa+V)*sxa2)+1.0)*cxa*exp(( Vxa+V)*sxa1);
    betax = 1.0/( exp(( Vxb+V)*sxb2)+1.0)*exp(( Vxb+V)*sxb1)*cxb;
    taux = 1.0/( betax+alphax)*gamma;
    xinf = 1.0/( betax+alphax)*alphax;
    xi = cxi/( Vxi1+V)/exp(sxi*( Vxi2+V))*( exp(( Vxi1+V)*sxi)-1.0);
    alphaK1 = 1.0/( exp(-( VK1-V+5.9215000000000003e+01)*sK1a)+1.0)*cK1a;
    betaK1 = ( cK1b*exp(-( VK1-V-5.4760000000000000e+00)*sK1b1)+exp(-( VK1-V+5.9430999999999995e+02)*sK1b2))/( exp(-( VK1-V-4.7530000000000001e+00)*sK1b3)+1.0);
    K1inf = 1.0/( alphaK1+betaK1)*alphaK1;
    Kp = 1.0/( exp(sKp*( VKp-V))+1.0);
    ICa = -gCa*d*f*( VCa-V);
    IK = -gK*xi*( VK-V)*x;
    IK1 = -K1inf*( VK1-V)*gK1;
    IKp = -( VK1-V)*Kp*gKp;
    Ib = gb*( Vb+V);

    /* The vector field */

    f_[0] = T*(-1.0/C*( Ib+IK+IK1+IKp+ICa));
    f_[1] = T*(-1.0/(C*taud)*( d-dinf));
    f_[2] = T*(-1.0/tauf*(f-finf));
    f_[3] = T*(-1.0/taux*(x-xinf));

}

/*
 *  STPNT  Gives a starting point
 */

int stpnt(integer ndim_, doublereal t_, doublereal *u_, doublereal *par_)
{
    const double Ki = 145.0;
    const double Nao = 140.0;
    const double Nai = 18.0;
    const double PRNaK = 1.8329999999999999e-02;
    const double R = 8.3144598000000005e+03;
    const double Kelvin = 3.0450000000000000e+02;
    const double Faraday = 9.5484559999999998e+04;
    const double cda = 9.5000000000000001e-02;
    const double cdb = 7.0000000000000007e-02;
    const double cfa = 1.2000000000000000e-02;
    const double cfb = 6.4999999999999997e-03;
    const double cxa = 5.0000000000000001e-04;
    const double cxb = 1.2999999999999999e-03;
    const double cxi = 2.8370000000000002e+00;
    const double cK1a = 1.0200000000000000e+00;
    const double cK1b = 4.9124000000000001e-01;
    const double Vda = -5.0000000000000000e+00;
    const double Vdb = 4.4000000000000000e+01;
    const double Vfa = 2.8000000000000000e+01;
    const double Vfb = 3.0000000000000000e+01;
    const double Vxa = 5.0000000000000000e+01;
    const double Vxb = 2.0000000000000000e+01;
    const double Vxi1 = 7.7000000000000000e+01;
    const double Vxi2 = 3.5000000000000000e+01;
    const double sda1 = -1.0000000000000000e-02;
    const double sda2 = -7.1999999999999995e-02;
    const double sdb1 = -1.7000000000000001e-02;
    const double sdb2 = 5.0000000000000003e-02;
    const double sfa1 = -8.0000000000000002e-03;
    const double sfa2 = 1.4999999999999999e-01;
    const double sfb1 = -2.0000000000000000e-02;
    const double sfb2 = -2.0000000000000001e-01;
    const double sxa1 = 8.3000000000000004e-02;
    const double sxa2 = 5.7000000000000002e-02;
    const double sxb1 = -5.9999999999999998e-02;
    const double sxb2 = -4.0000000000000001e-02;
    const double sxi = 4.0000000000000001e-02;
    const double sK1a = 2.3849999999999999e-01;
    const double sK1b1 = 8.0320000000000003e-02;
    const double sK1b2 = 6.1749999999999999e-02;
    const double sK1b3 = -5.1429999999999998e-01;
    const double sKp = 1.6722408026755853e-01;
    const double gK1w = 6.0470000000000002e-01;
    const double gKp = 1.8300000000000000e-02;
    const double gb = 3.9210000000000002e-02;
    const double VKp = 7.4880000000000004e+00;
    const double Vb = 5.9869999999999997e+01;
    double V, d, f, x;
    double C, Ko, gKw, gCa, VCa, alpha, beta, gamma, T;

    /* Change the parameter values and the starting point to correct values! */

    C = 0.2;
    Ko = 5.4000000000000004e+00;
    gKw = 2.8199999999999997e-01;
    gCa = 0.15;
    VCa = 8.0000000000000000e+01;
    alpha = 0.1;
    beta = 1.1;
    gamma = 10.0;

    T = 0;

    /*location of FNS*/

    V = -15.32231875;
    d = 0.725593746;
    f = 0.2285426277;
    x = 0.1496068449;

    par_[0] = C;
    par_[1] = Ko;
    par_[2] = gKw;
    par_[3] = gCa;
    par_[4] = VCa;
    par_[5] = alpha;
    par_[6] = beta;
    par_[7] = gamma;

    par_[10] = T;

    u_[0] = V;
    u_[1] = d;
    u_[2] = f;
    u_[3] = x;

   /* boundary condition params */

    par_[8] = u_[0]; /* V(0) */
    par_[9] = u_[1]; /* d(0) */
    par_[11] = u_[2]; /* f(0) */
    par_[12] = u_[3]; /* x(0) */
    par_[13] = u_[0]; /* V(1) */
    /*par_[14] = u_[1]; /* d(1) */
    /*par_[15] = u_[2]; /* f(1) */
    /*par_[16] = u_[3]; /* x(1) */

    return 0;
}


/*
 *  BCND  Defines the boundary conditions
 */

int bcnd(integer ndim_, const doublereal *par_, const integer *icp_,
         integer nbc_, const doublereal *u0_, const doublereal *u1_, integer ijac_,
         doublereal *fb_, doublereal *dbc_)
{  
    const double Ki = 145.0;
    const double Nao = 140.0;
    const double Nai = 18.0;
    const double PRNaK = 1.8329999999999999e-02;
    const double R = 8.3144598000000005e+03;
    const double Kelvin = 3.0450000000000000e+02;
    const double Faraday = 9.5484559999999998e+04;
    const double cda = 9.5000000000000001e-02;
    const double cdb = 7.0000000000000007e-02;
    const double cfa = 1.2000000000000000e-02;
    const double cfb = 6.4999999999999997e-03;
    const double cxa = 5.0000000000000001e-04;
    const double cxb = 1.2999999999999999e-03;
    const double cxi = 2.8370000000000002e+00;
    const double cK1a = 1.0200000000000000e+00;
    const double cK1b = 4.9124000000000001e-01;
    const double Vda = -5.0000000000000000e+00;
    const double Vdb = 4.4000000000000000e+01;
    const double Vfa = 2.8000000000000000e+01;
    const double Vfb = 3.0000000000000000e+01;
    const double Vxa = 5.0000000000000000e+01;
    const double Vxb = 2.0000000000000000e+01;
    const double Vxi1 = 7.7000000000000000e+01;
    const double Vxi2 = 3.5000000000000000e+01;
    const double sda1 = -1.0000000000000000e-02;
    const double sda2 = -7.1999999999999995e-02;
    const double sdb1 = -1.7000000000000001e-02;
    const double sdb2 = 5.0000000000000003e-02;
    const double sfa1 = -8.0000000000000002e-03;
    const double sfa2 = 1.4999999999999999e-01;
    const double sfb1 = -2.0000000000000000e-02;
    const double sfb2 = -2.0000000000000001e-01;
    const double sxa1 = 8.3000000000000004e-02;
    const double sxa2 = 5.7000000000000002e-02;
    const double sxb1 = -5.9999999999999998e-02;
    const double sxb2 = -4.0000000000000001e-02;
    const double sxi = 4.0000000000000001e-02;
    const double sK1a = 2.3849999999999999e-01;
    const double sK1b1 = 8.0320000000000003e-02;
    const double sK1b2 = 6.1749999999999999e-02;
    const double sK1b3 = -5.1429999999999998e-01;
    const double sKp = 1.6722408026755853e-01;
    const double gK1w = 6.0470000000000002e-01;
    const double gKp = 1.8300000000000000e-02;
    const double gb = 3.9210000000000002e-02;
    const double VKp = 7.4880000000000004e+00;
    const double Vb = 5.9869999999999997e+01;

    /* first are either parameters or expressions involving parameters I used to replace in BCNDs */

    /*par_[0] = C;
    par_[1] = Ko;
    par_[2] = gKw;
    par_[3] = gCa;
    par_[4] = VCa;
    par_[5] = alpha;
    par_[6] = beta;
    par_[7] = gamma;
    gK = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gKw;
    gK1 = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gK1w;
    VK = 1.0/Faraday*log(( PRNaK*Nao+Ko)/( Ki+PRNaK*Nai))*R*Kelvin;
    VK1 = 1.0/Faraday*R*log(1.0/Ki*Ko)*Kelvin; */

    /* second are expressions used to define the det(J) of the fast subsystem I used to replace in BCNDs */

    /*dinfalpha = 1.0/( exp(-sda2*( Vda+V))+1.0);
    dalphad = -( dinfalpha*sda2-sda1)*alphad;
    dinfbeta = 1.0/( exp(-sdb2*( Vdb+V))+1.0);
    dbetad = -betad*( dinfbeta*sdb2-sdb1);
    ddinfdV = taud/alpha*( dalphad-( dbetad+dalphad)*dinf);
    dxidV = -( xi-cxi/exp(sxi*( Vxi2+V))*sxi)/( Vxi1+V);
    dalphaK1 = ( 1.0/cK1a*alphaK1-1.0)*alphaK1*sK1a;
    K1infbeta = 1.0/( exp(( VK1-V-4.7530000000000001e+00)*sK1b3)+1.0);
    dbetaK1 = -betaK1*K1infbeta*sK1b3+( exp(-sK1b2*( VK1-V+5.9430999999999995e+02))*sK1b2+cK1b*sK1b1*exp(-sK1b1*( VK1-V-5.4760000000000000e+00)))/( exp(-( VK1-V-4.7530000000000001e+00)*sK1b3)+1.0);
    dK1dV = -( ( dbetaK1+dalphaK1)*K1inf-dalphaK1)/( betaK1+alphaK1);
    dKpdV = -sKp*Kp*( Kp-1.0);
    dfdt = 1.0/tauf*( finf-f);
    dxdt = -( x-xinf)/taux;
    dFdV = -K1inf*gK1-gb+( VK1-V)*dKpdV*gKp+( VK1-V)*gK1*dK1dV-gCa*f*dinf-gKp*Kp+gCa*ddinfdV*f*( VCa-V)+x*( VK-V)*gK*dxidV-x*gK*xi;
    dFdf = gCa*( VCa-V)*dinf;
    dFdx = ( VK-V)*gK*xi; */

    /* critical manifold fb_[0]*/

    fb_[0] = /*ICa*/ par_[3]*u0_[1]*u0_[2]*(u0_[0]-par_[4])+
             /*IK*/ (4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*par_[2])*(cxi/(Vxi1+u0_[0])/exp(sxi*(Vxi2+u0_[0]))*(exp((Vxi1+u0_[0])*sxi)-1.0))*u0_[3]*(u0_[0]-(1.0/Faraday*log((PRNaK*Nao+par_[1])/(Ki+PRNaK*Nai))*R*Kelvin))+
             /*IK1*/ (4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*gK1w)*(1.0/((1.0/( exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215000000000003e+01)*sK1a)+1.0)*cK1a)+((cK1b*exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.4760000000000000e+00)*sK1b1)+exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9430999999999995e+02)*sK1b2))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.7530000000000001e+00)*sK1b3)+1.0)))*(1.0/( exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215000000000003e+01)*sK1a)+1.0)*cK1a))*(u0_[0]-(1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin))+
             /*IKp*/ gKp*(1.0/(exp(sKp*(VKp-u0_[0]))+1.0))*(u0_[0]-(1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin))+
             /*Ib*/ gb*(u0_[0]+Vb);

    fb_[1] = u0_[0] - par_[8];
    fb_[2] = u0_[1] - par_[9];
    fb_[3] = u0_[2] - par_[11];
    fb_[4] = u0_[3] - par_[12];
    fb_[5] = u1_[0] - par_[13];
    
    /* d = dinf(V) */

    fb_[6] = u0_[1] - (exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)/((exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)+(1.0/(exp(sdb2*(Vdb+u0_[0]))+1.0)*exp(sdb1*(Vdb+u0_[0]))*cdb));
    
    if(nbc_ == 7){return 0;}

    /* fb_[0] and fb_[7] together define the fold curve */    

    fb_[7] = /*dIK1dV*/-(1.0/((1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)+((cK1b*exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.476)*sK1b1)+exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9431e+02)*sK1b2))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0)))*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a))*(4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*gK1w)-
             /*dIbdV*/gb+
             /*dIKpdV*/((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0])*(-sKp*(1.0/( exp(sKp*(VKp-u0_[0]))+1.0))*((1.0/(exp(sKp*(VKp-u0_[0]))+1.0))-1.0))*gKp+
             /*dIK1dV*/((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0])*(4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*gK1w)*(-(((-((cK1b*exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.476)*sK1b1)+exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9431e+02)*sK1b2))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0))*(1.0/(exp(((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0))*sK1b3+(exp(-sK1b2*((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9431e+02))*sK1b2+cK1b*sK1b1*exp(-sK1b1*((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.476)))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0))+((1.0/cK1a*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)-1.0)*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)*sK1a))*(1.0/((1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)+((cK1b*exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.476)*sK1b1)+exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9431e+02)*sK1b2))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0)))*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a))-((1.0/cK1a*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)-1.0)*(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)*sK1a))/(((cK1b*exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-5.476)*sK1b1)+exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9431e+02)*sK1b2))/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]-4.753)*sK1b3)+1.0))+(1.0/(exp(-((1.0/Faraday*R*log(1.0/Ki*par_[1])*Kelvin)-u0_[0]+5.9215e+01)*sK1a)+1.0)*cK1a)))-
             /*dICadV*/par_[3]*u0_[2]*u0_[1]-
             /*dIKpdV*/gKp*(1.0/(exp(sKp*(VKp-u0_[0]))+1.0))+
             /*dICadV*/par_[3]*((1.0/((exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)+(1.0/(exp(sdb2*(Vdb+u0_[0]))+1.0)*exp(sdb1*(Vdb+u0_[0]))*cdb)))*((-((1.0/(exp(-sda2*(Vda+u0_[0]))+1.0))*sda2-sda1)*(exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda))-((-(1.0/(exp(sdb2*(Vdb+u0_[0]))+1.0)*exp(sdb1*(Vdb+u0_[0]))*cdb)*((1.0/(exp(-sdb2*(Vdb+u0_[0]))+1.0))*sdb2-sdb1))+(-((1.0/(exp(-sda2*(Vda+u0_[0]))+1.0))*sda2-sda1)*(exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)))*((exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)/((exp((Vda+u0_[0])*sda1)/(exp(sda2*(Vda+u0_[0]))+1.0)*cda)+(1.0/(exp(sdb2*(Vdb+u0_[0]))+1.0)*exp(sdb1*(Vdb+u0_[0]))*cdb)))))*u0_[2]*(par_[4]-u0_[0])+
             /*dIKdV*/u0_[3]*((1.0/Faraday*log(( PRNaK*Nao+par_[1])/( Ki+PRNaK*Nai))*R*Kelvin)-u0_[0])*(4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*par_[2])*(-((cxi/(Vxi1+u0_[0])/exp(sxi*(Vxi2+u0_[0]))*(exp((Vxi1+u0_[0])*sxi)-1.0))-cxi/exp(sxi*(Vxi2+u0_[0]))*sxi)/(Vxi1+u0_[0]))-u0_[3]*(4.3033148291193524e-01*pow(par_[1],(1.0/2.0))*par_[2])*(cxi/(Vxi1+u0_[0])/exp(sxi*(Vxi2+u0_[0]))*(exp((Vxi1+u0_[0])*sxi)-1.0));
 
    return 0;
}

/*
 *  ICND  Defines the integral conditions
 */

int icnd(integer ndim_, const doublereal *par_, const integer *icp_,
         integer nint_, const doublereal *u_, const doublereal *uold_,
         const doublereal *udot_, const doublereal *upold_, integer ijac_,
         doublereal *fi_, doublereal *dint_)
{
    return 0;
}

/*
 *  FOPT
 */

int fopt(integer ndim_, const doublereal *u_, const integer *icp_,
         const doublereal *par_, integer ijac_,
         doublereal *fs_, doublereal *dfdu_, doublereal *dfdp_)
{
    return 0;
}

/*
 *  PVLS
 */

int pvls(integer ndim_, const doublereal *u_, doublereal *par_)
{   

    par_[14] = getp("BV1", 2, u_); /* d(1) */
    par_[15] = getp("BV1", 3, u_); /* f(1) */
    par_[16] = getp("BV1", 4, u_); /* x(1) */
    
    return 0;
}
